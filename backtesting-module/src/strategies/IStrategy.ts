/**
 * Base Strategy Interface
 * Defines the contract for all trading strategies
 */

import { Candle } from "../adapters/CSVDataLoader.js";

/**
 * Trading signal generated by strategy
 */
export interface Signal {
  type: "BUY" | "SELL" | "CLOSE";
  timestamp: number;
  price: number;
  stopLoss?: number;
  takeProfit?: number;
  size?: number; // position size
  reason: string; // why this signal was generated
  confidence?: number; // 0-1, optional
}

/**
 * Market context for strategy analysis
 */
export interface MarketContext {
  candles: Candle[]; // historical candles for analysis
  currentIndex: number; // current position in backtest
  balance: number; // current account balance
  openPosition?: Position; // currently open position if any
}

/**
 * Open trading position
 */
export interface Position {
  id: string;
  type: "LONG" | "SHORT";
  entryPrice: number;
  entryTime: number;
  size: number;
  stopLoss?: number;
  takeProfit?: number;
  currentPrice: number;
  unrealizedPnL: number;
}

/**
 * Trade record (closed position)
 */
export interface Trade {
  id: string;
  type: "LONG" | "SHORT";
  entryPrice: number;
  entryTime: number;
  exitPrice: number;
  exitTime: number;
  size: number;
  pnl: number; // profit/loss
  pnlPct: number; // profit/loss percentage
  duration: number; // trade duration in ms
  stopLoss?: number;
  takeProfit?: number;
  exitReason: "TP" | "SL" | "SIGNAL" | "TIMEOUT";
}

/**
 * Base Strategy Interface
 * All trading strategies must implement this interface
 */
export interface IStrategy {
  /**
   * Strategy name
   */
  readonly name: string;

  /**
   * Strategy description
   */
  readonly description: string;

  /**
   * Analyze current market conditions and generate signal
   * 
   * @param candle - current candle
   * @param context - market context with historical data
   * @returns Trading signal or null if no signal
   */
  analyze(candle: Candle, context: MarketContext): Signal | null;

  /**
   * Called when a trade is opened
   * Strategy can use this to track state
   */
  onTradeOpen?(trade: Position): void;

  /**
   * Called when a trade is closed
   * Strategy can use this to update internal state
   */
  onTradeClose?(trade: Trade): void;

  /**
   * Reset strategy state
   * Called before starting a new backtest
   */
  reset(): void;

  /**
   * Get strategy statistics
   */
  getStats?(): Record<string, any>;
}

/**
 * Simple Moving Average helper
 */
export function calculateSMA(data: number[], period: number): number | null {
  if (data.length < period) return null;
  const slice = data.slice(-period);
  return slice.reduce((a, b) => a + b, 0) / period;
}

/**
 * Exponential Moving Average helper
 */
export function calculateEMA(
  data: number[],
  period: number,
  prevEMA?: number
): number | null {
  if (data.length === 0) return null;
  
  const multiplier = 2 / (period + 1);
  const current = data[data.length - 1];
  
  if (prevEMA === undefined) {
    // First EMA = SMA
    return calculateSMA(data, period);
  }
  
  return (current - prevEMA) * multiplier + prevEMA;
}

/**
 * Average True Range (ATR) helper
 */
export function calculateATR(
  candles: Candle[],
  period: number = 14
): number | null {
  if (candles.length < period + 1) return null;

  const trueRanges: number[] = [];

  for (let i = 1; i < candles.length; i++) {
    const high = candles[i].high;
    const low = candles[i].low;
    const prevClose = candles[i - 1].close;

    const tr = Math.max(
      high - low,
      Math.abs(high - prevClose),
      Math.abs(low - prevClose)
    );

    trueRanges.push(tr);
  }

  return calculateSMA(trueRanges.slice(-period), period);
}

/**
 * Relative Strength Index (RSI) helper
 */
export function calculateRSI(
  prices: number[],
  period: number = 14
): number | null {
  if (prices.length < period + 1) return null;

  const changes: number[] = [];
  for (let i = 1; i < prices.length; i++) {
    changes.push(prices[i] - prices[i - 1]);
  }

  const recentChanges = changes.slice(-period);
  const gains = recentChanges.filter((c) => c > 0);
  const losses = recentChanges.filter((c) => c < 0).map(Math.abs);

  const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / period : 0;
  const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / period : 0;

  if (avgLoss === 0) return 100;

  const rs = avgGain / avgLoss;
  return 100 - 100 / (1 + rs);
}
